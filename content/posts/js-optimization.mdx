---
slug: js-optimization
title: JS optimizācijas tehnikas 2021 gadā
date: 2021-04-20
author: gabriels
tags:
  - js
---
Izstrādātājs vienmēr mācās jaunas lietas, un sekot izmaiņām nevajadzētu būt grūtāk nekā tas jau ir. Mans motīvs ir iepazīstināt jūs ar visām labākajām praksēm JavaScript valodā, kuras jums jāzina kā frontend izstrādātājam lai atvieglot jūsu dzīvi 2021. gadā.

![](https://miro.medium.com/max/1200/0*K49jVcTGrpgm_5mX.png)

You might be doing JavaScript development for a long time but sometimes you might be not updated with the newest features which can solve your issues without doing or writing some extra codes. These techniques can help you to write clean and optimized JavaScript Code. Moreover, these topics can help you to prepare yourself for JavaScript interviews in 2021.

Iespējams ka jūs ilgu laiku izstrādājat ar JS, taču dažreiz jūs, iespējams, netiksiet informēti par jaunām funkcijām, kas var atrisināt jūsu problēmas nerakstot papildu kodu. Šīs metodes var jums palīdzēt uzrakstīt tīru un optimizētu JS kodu. Turklāt šīs tēmas var palīdzēt jums sagatavoties JS intervijām 2021. gadā.

# 1. If with multiple conditions

Mēs varam array saglabāt vairākas vērtības, un mēs varam izmantot array includes metodi.

```javascript
//longhand
if (x === 'abc' || x === 'def' || x === 'ghi' || x ==='jkl') {
    //logic
}
//shorthand
if (['abc', 'def', 'ghi', 'jkl'].includes(x)) {
   //logic
}
```

# 2. If true … else Shorthand

Šis ir lielāks saīsinājums ja ir if-else nosacījumi kuri neiekļauj lielākas loģikas. Mēs varam vienkārši izmantot ternary operatorus lai sasniegtu šo.

```javascript
// Longhand
let test: boolean;
if (x > 100) {
    test = true;
} else {
    test = false;
}
// Shorthand
let test = (x > 10) ? true : false;
//or we can use directly
let test = x > 10;
console.log(test);
```

Kad mums ir ligzdoti apstākļi, mēs varam darīt šādi:

```javascript
let x = 300,
test2 = (x > 100) ? 'greater 100' : (x < 50) ? 'less 50' : 'between 50 and 100';
console.log(test2); // "greater than 100"
```

# 3. Variable deklarēšana

Kad mēs vēlamies deklarēt divus mainīgos, kuriem ir kopēja vērtība vai tips, mēs varam izmantot šo shorthand.

```javascript
//Longhand 
let test1;
let test2 = 1;
//Shorthand 
let test1, test2 = 1;
```

# 4. Null, Undefined, Empty pārbaude

Veidojot jaunus mainīgos, dažreiz mēs vēlamies pārbaudīt, vai mainīgais uz kura vērtību atsaucamies, nav null vai nav definēts. JS ir ļoti labs shorthand lai sasniegtu šīs funkcijas.

```javascript
// Longhand
if (test1 !== null || test1 !== undefined || test1 !== '') {
    let test2 = test1;
}
// Shorthand
let test2 = test1 || '';
```

# 5. Null vērtības pārbaude un noklusējuma vērtības piešķiršana

```javascript
let test1 = null,
    test2 = test1 || '';
console.log("null check", test2); // izejošais būs ""
```

# 6. Vērtību piešķiršana vairākiem variable

Kad mēs strādājam ar vairākiem mainīgajiem un gribam piešķirt atšķirīgas vērtības dažādiem variable, šī tehnika ir ļoti noderīga.

```javascript
//Longhand 
let test1, test2, test3;
test1 = 1;
test2 = 2;
test3 = 3;
//Shorthand 
let [test1, test2, test3] = [1, 2, 3];
```

# 7. Uzdevuma operatoru shorthand

Mēs nodarbojamies ar daudz aritmētiskiem operatoriem. Šī ir viena no noderīgajām metodēm priekš uzdevumu operatoriem priekš mainīgā.

```javascript
// Longhand
test1 = test1 + 1;
test2 = test2 - 1;
test3 = test3 * 20;
// Shorthand
test1++;
test2--;
test3 *= 20;
```

# 8. If klātbūtnes shorthand

Šis ir viens no izplatītākajiem shorthand kuru mēs visi izmantojam, taču tomēr ir vērts šeit pieminēt.

```javascript
// Longhand
if (test1 === true) or if (test1 !== "") or if (test1 !== null)

// Shorthand //it will check empty string,null and undefined too
if (test1)
```

# 9. UN (&&) operators priekš vairākiem stāvokļiem

Ja mēs izsaucam funkciju tikai ja mainīgais ir patiess, tad mēs varam izmantot `&&` operatoru.

```javascript

```

# 10. foreach cilpas Shorthand

Šī ir viena no izplatītākajām īsās tehnikas iterācija.

```javascript
// Longhand
for (var i = 0; i < testData.length; i++)

// Shorthand
for (let i in testData) or  for (let i of testData)
```

Array katram mainīgajam

```javascript
function testData(element, index, array) {
  console.log('test[' + index + '] = ' + element);
}

[11, 24, 32].forEach(testData);
// logs: test[0] = 11, test[1] = 24, test[2] = 32
```

# 11. Arrow funkcijas

```javascript
//Longhand 
function add(a, b) { 
   return a + b; 
} 
//Shorthand 
const add = (a, b) => a + b;
```

Vairāk piemēri.

```javascript
function callMe(name) {
  console.log('Hello', name);
}
callMe = name => console.log('Hello', name);
```

# 12. Short Function Calling

Mēs varam izmantot ternary operatoru lai sasniegtu šīs funkcijas.

```javascript
// Longhand
function test1() {
  console.log('test1');
};
function test2() {
  console.log('test2');
};
var test3 = 1;
if (test3 == 1) {
  test1();
} else {
  test2();
}
// Shorthand
(test3 === 1? test1 : test2)();
```

# 13. Switch shorthands

Mēs varam saglabāt nosacījumus atslēgas-vērtīas objektos, un tos var izmantot pamatojoties uz nosacījumiem.

```javascript
// Longhand
switch (data) {
  case 1:
    test1();
  break;

  case 2:
    test2();
  break;

  case 3:
    test();
  break;
  // Un tā tālāk...
}

// Shorthand
var data = {
  1: test1,
  2: test2,
  3: test
};

data[something] && data[something]();
```

# 14. Netieša atgriešanās shorthand

Izmantojot arrow funkcijas, mēs varam tieši atgriezt vērtību, nerakstot atgriešanas apgalvojumu.

```javascript
//longhand
function calculate(diameter) {
  return Math.PI * diameter
}
//shorthand
calculate = diameter => (
  Math.PI * diameter;
)
```

# 15. Decimāldaļas bāzes eksponenti

```javascript
// Longhand
for (var i = 0; i < 10000; i++) { ... }

// Shorthand
for (var i = 0; i < 1e4; i++) { ... }
```

# 16. Noklusējuma parametru vērtības saīsinājums

```javascript
//Longhand
function add(test1, test2) {
  if (test1 === undefined)
    test1 = 1;
  if (test2 === undefined)
    test2 = 2;
  return test1 + test2;
}
//shorthand
add = (test1 = 1, test2 = 2) => (test1 + test2);
add() //output: 3
```

# 17. Izplašanās operatora saīsinājums

```javascript
//longhand
// joining arrays using concat
const data = [1, 2, 3];
const test = [4 ,5 , 6].concat(data);
//shorthand
// joining arrays
const data = [1, 2, 3];
const test = [4 ,5 , 6, ...data];
console.log(test); // [ 4, 5, 6, 1, 2, 3]
```

Arī klonēšanai mēs varam izmantot izplatīšanas operatoru.

```javascript
//longhand

// cloning arrays
const test1 = [1, 2, 3];
const test2 = test1.slice()
//shorthand

// cloning arrays
const test1 = [1, 2, 3];
const test2 = [...test1];
```

# 18. Veidņu literāļu saīsinājums

Ja jums ir apnicis izmantot +, lai apvienotu vairākus mainīgos vienā virknē, šis saīsinājums noņem jūsu galvassāpes.

```javascript
//longhand
const welcome = 'Hi ' + test1 + ' ' + test2 + '.'
//shorthand
const welcome = `Hi ${test1} ${test2}`;
```

# 19. Vairāku rindu virknes saīsinājums

Kad mēs strādājam ar vairāku rindu virkni kodā, mēs varam izmantot šo funkciju:

```javascript
//longhand
const data = 'abc abc abc abc abc abc\n\t'
    + 'test test,test test test test\n\t'
//shorthand
const data = `abc abc abc abc abc abc
         test test,test test test test`
```

# 20. Objekta rekvizītu piešķiršanas saīsinājums

```javascript
let test1 = 'a'; 
let test2 = 'b';
//Longhand 
let obj = {test1: test1, test2: test2}; 
//Shorthand 
let obj = {test1, test2};
```

# 21. Virkne uz ciparu saīsinājums

```javascript
//Longhand 
let test1 = parseInt('123'); 
let test2 = parseFloat('12.3'); 
//Shorthand 
let test1 = +'123'; 
let test2 = +'12.3';
```

# 22. Pārstrukturēšanas uzdevuma saīsinājums

```javascript
//longhand
const test1 = this.data.test1;
const test2 = this.data.test2;
const test2 = this.data.test3;
//shorthand
const { test1, test2, test3 } = this.data;
```

# 23. Array.find saīsinājums

Kad mums ir array ar objectiem un mēs gribam atrast konkrētu objektu pamatojoties uz objekta īpašībām, find metode ir ļoti noderīga.

```javascript
const data = [{
        type: 'test1',
        name: 'abc'
    },
    {
        type: 'test2',
        name: 'cde'
    },
    {
        type: 'test1',
        name: 'fgh'
    },
]
function findtest1(name) {
    for (let i = 0; i < data.length; ++i) {
        if (data[i].type === 'test1' && data[i].name === name) {
            return data[i];
        }
    }
}

//Shorthand
filteredData = data.find(data => data.type === 'test1' && data.name === 'fgh');
console.log(filteredData); // { type: 'test1', name: 'fgh' }
```

# 24. Uzmeklēšanas nosacījumu saīsinājums

Ja mums ir kods lai pārbaudītu veidu, un, pamatojoties uz tipu, ir jāizsauc dažādas metodes, mums vai nu ir iespēja izmantot vairākus `else if` vai pāriet uz `switch`, bet ja nu mums būtu labāks saīsinājums par to?

```javascript
// Longhand
if (type === 'test1') {
  test1();
}
else if (type === 'test2') {
  test2();
}
else if (type === 'test3') {
  test3();
}
else if (type === 'test4') {
  test4();
} else {
  throw new Error('Invalid value ' + type);
}
// Shorthand
var types = {
  test1: test1,
  test2: test2,
  test3: test3,
  test4: test4
};
 
var func = types[type];
(!func) && throw new Error('Invalid value ' + type); func();
```

# 25. Bitwise IndexOf saīsinājums

Kad mēs atkārtojam array lai atrastu noteiktu vērtību, mēs izmantojam `indexOf()` metodi. Ko darīt ja mēs tam atradīsim labāku pieeju? Apskatīsim piemēru.

```javascript
//longhand
if(arr.indexOf(item) > -1) { // item found 
}
if(arr.indexOf(item) === -1) { // item not found
}
//shorthand
if(~arr.indexOf(item)) { // item found
}
if(!~arr.indexOf(item)) { // item not found
}
```

Operators `bitwise(~)` atgriezīs patiesu vērtību jebkuram citam izņemot `-1`. Noliegt to ir tikpat vienkārši kā darīt `!~`. Alternatīvi, mēs varam izmantot arī `includes()` funkciju.

```javascript
if (arr.includes(item)) { 
// true if the item found
}
```

# 26. Object.entries()

Šī funkcija palīdz pārveidot objectu uz objektu array.

```javascript
const data = { test1: 'abc', test2: 'cde', test3: 'efg' };
const arr = Object.entries(data);
console.log(arr);
/** Output:
[ [ 'test1', 'abc' ],
  [ 'test2', 'cde' ],
  [ 'test3', 'efg' ]
]
**/
```

# 27. Object.values()

Šī arī ir jauna ES8 ieviesta funkcija, kas veic līdzīgu kā `Object.entries()`, bet bez atslēgdaļas

```javascript
const data = { test1: 'abc', test2: 'cde' };
const arr = Object.values(data);
console.log(arr);
/** Output:
[ 'abc', 'cde']
**/
```

# 28. Dubult bitwise saīsinājums

**(Dubult bitwise NĒ operatora pieeja tikai strāda priekš 32-bitu integer )**

```javascript
// Longhand
Math.floor(1.9) === 1 // true

// Shorthand
~~1.9 === 1 // true
```

# 29. Atkārtot virkni vairākas reizes

Lai atkārtotu tās pašas rakstzīmes atkal un atkal, mēs varam izmantot for ciklu un pievienot tos tajā pašā cilpā, bet ko darīt ja mums tam ir saīsinājums?

```javascript
//longhand 
let test = ''; 
for(let i = 0; i < 5; i ++) { 
  test += 'test '; 
} 
console.log(str); // test test test test test 
//shorthand 
'test '.repeat(5);
```

# 30. Atrast mazāko un lielāko skaitli iekšā array

```javascript
const arr = [1, 2, 3]; 
Math.max(…arr); // 3
Math.min(…arr); // 1
```

# 31. Dabūt burtu no virknes

```javascript
let str = 'abc';
//Longhand 
str.charAt(2); // c
//Shorthand 
str[2]; // c
```

P.S: Ja mēs zinām array indeksu, tad rakstzīmes vietā mēs varam tieši izmantot indeksu. Ja mēs neesam pārliecināti par indeksu, tas var izmest undefined.

# 32. Power Shorthand

Saīsinājums Math eksponenta jaudas funkcijai:

```javascript
//longhand
Math.pow(2,3); // 8
//shorthand
2**3 // 8
```